# glob通配及IO重定向

## 匹配模式

1. *****是匹配任意长度的字符
2. **?**是匹配任意单个字符
3. **[集合]**匹配指定范围内的任意**单个**字符，如：[a-z],[0-9],[a-z0-9],这里的a-z不区分大小写，除非我们自己指定范围。[[:upper:]]匹配大写字符, [[:lower:]]、 [[:alpha:]]、[[:digit:]], alpha是所有字母， digit是所有数字。[[:space:]]【空格】、[[:alnum:]]【所有数字】、[[::]]
4. **[^]**匹配所有范围外的字符 ， 如[\^0-9] 匹配所有非数字的

## IO重定向及管理

**fd**: file decriptor 文件描述符， 标准输入：0， 标准输出：1， 错误输出：2

### 输出重定向

正确输出重定向使用符号：**>**  导出到一个文件或者设备。```cat something > /dev/tty1```。这就把一个内容输出到tty1终端了。这个是属于覆盖输出，目标的文件会被全覆盖。

**>>** 作用基本同 **>**, 但是这个属于追加输出，不会覆盖目标文件，在尾部追加。 ```cat aa >> 1.txt```

> set -C : 禁止输出重定向到已经存在的文件， cat /etc/1.txt  **>|** /temp/1.txt: 强制覆盖。set +C关闭上述限制。只对当前进程有效。

错误输出(错误的信息)重定向：**2>**, **2>>** , 这两个是只能对错误信息进行重定向。正确的输出管不到。

合并两者（正常，错误）的输出流：**&>， &>>**,这两个符号都能把两种的输出保存在目标文件。还有一种方式也是可以达到这种效果：```cat /etc/file >> /temp/file1 2>&1```,**这句话的意思是如果是正常的输出则到/tem/file1, 如果是错误的输出流则重定向到正确流上， 然后再到了 /temp/file1上面。**  只能使用一个 > ,且中间没有空格字符。

**特殊设备： /dev/null ,黑洞。** 等于丢弃 ```cat /etc/file > /dev/null``` ,然后使用echo $? 可以看到命令的执行结果状态。0或者2。 也可以把 2>&1 改为 2>/dev/null.  即不关心错误结果。

### 输入重定向

大多数命令不需要使用输入重定向， 如果要用如cat就可以使用 **<** 来进行， cat < 1.txt 。那么我们的命令就 cat 1.txt中的文本内容。

还有如 **tr** 命令也可以使用 ```tr [a-z] [A-Z] < 1.txt``` 这句话就是把1.txt所有的小写改成大写。 tr 还有-d 选项。做删除 。 tr -d 'abc' < 1.txt 删除abc 。 这个操作不会改变文件，只是显示到屏幕上。

**<<**: 两个小于号表示指定结束符号： cat << EOF， 就表示EOF为结束符。```cat  > /etc/temfile  >> EOF

### 管道

将前一个命令的输出当做后一个命令的输入：```command1 | command2 | command3 | ·········```。 但是这样我们就只有一个输出且是看不到的。 我们可以用 **tee** 命令来完成两道输出，一个给后面的命令， 一个自己用。使用示例：

```bash
cat 1.txt | tee 2.txt | tr 'a-z' 'A-Z'  # 就是把cat 命令传递个tee ,tee保存到2.txt 后发给 tr命令
```



